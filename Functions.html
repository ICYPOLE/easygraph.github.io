
<!DOCTYPE html>

<html>
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Functions &#8212; Easy Graph 0.1 documentation</title>
    <link rel="stylesheet" href="_static/alabaster.css" type="text/css" />
    <link rel="stylesheet" href="_static/pygments.css" type="text/css" />
    <script id="documentation_options" data-url_root="./" src="_static/documentation_options.js"></script>
    <script src="_static/jquery.js"></script>
    <script src="_static/underscore.js"></script>
    <script src="_static/doctools.js"></script>
    <script src="_static/language_data.js"></script>
    <link rel="index" title="Index" href="genindex.html" />
    <link rel="search" title="Search" href="search.html" />
    <link rel="next" title="Graph Classes" href="Graph Classes.html" />
    <link rel="prev" title="Welcome to test’s documentation!" href="index.html" />
   
  <link rel="stylesheet" href="_static/custom.css" type="text/css" />
  
  
  <meta name="viewport" content="width=device-width, initial-scale=0.9, maximum-scale=0.9" />

  </head><body>
  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          

          <div class="body" role="main">
            
  <div class="section" id="functions">
<h1>Functions<a class="headerlink" href="#functions" title="Permalink to this headline">¶</a></h1>
<p>For now, Easy Graph has implemented graph computation functions, including fundamental methods, for example, connected/biconnected components, community detection, PageRank; as well as advanced methods, for example, structure hole spanners detection, graph embedding. All of these functions are implemented with Python language in Easy Graph, even if the original authors of some graph computing methods are using different language, C and C++, for instance.</p>
<p>With the help of Easy Graph, users can easily try and compare different graph computation methods in the same platform.</p>
<div class="section" id="components">
<h2>Components<a class="headerlink" href="#components" title="Permalink to this headline">¶</a></h2>
<p>Easy Graph can help users check whether the graph (undirected) is connected/biconnected or not. It can also provide with connected/biconnected components.</p>
<div class="section" id="connected-components">
<h3>Connected Components<a class="headerlink" href="#connected-components" title="Permalink to this headline">¶</a></h3>
<p>Returns whether the graph is connected or not.</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="c1"># G: &lt;class &#39;Graph&#39;&gt;</span>
<span class="n">is_connected</span><span class="p">(</span><span class="n">G</span><span class="p">)</span>
</pre></div>
</div>
<p>Returns the number of connected components of graph.</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">number_connected_components</span><span class="p">(</span><span class="n">G</span><span class="p">)</span>
</pre></div>
</div>
<p>Returns the connected components of each node in graph.</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">connected_components</span><span class="p">(</span><span class="n">G</span><span class="p">)</span>
</pre></div>
</div>
<p>Returns the connected component of one node <code class="docutils literal notranslate"><span class="pre">Jack</span></code>.</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">connected_component_of_node</span><span class="p">(</span><span class="n">G</span><span class="p">,</span> <span class="n">node</span><span class="o">=</span><span class="s1">&#39;Jack&#39;</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="section" id="biconnected-components">
<h3>Biconnected Components<a class="headerlink" href="#biconnected-components" title="Permalink to this headline">¶</a></h3>
<p>Returns whether the graph is biconnected or not.</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="c1"># G: &lt;class &#39;Graph&#39;&gt;</span>
<span class="n">is_biconnected</span><span class="p">(</span><span class="n">G</span><span class="p">)</span>
</pre></div>
</div>
<p>Returns the biconnected components of each node in graph.</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">connected_components</span><span class="p">(</span><span class="n">G</span><span class="p">)</span>
</pre></div>
</div>
<p>Returns a generator of nodes in all biconnected components.</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">generator_biconnected_components_nodes</span><span class="p">(</span><span class="n">G</span><span class="p">)</span>
</pre></div>
</div>
<p>Returns a generator of edges in all biconnected components.</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">generator_biconnected_components_edges</span><span class="p">(</span><span class="n">G</span><span class="p">)</span>
</pre></div>
</div>
<p>Returns a generator of the articulation points.</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">generator_articulation_points</span><span class="p">(</span><span class="n">G</span><span class="p">)</span>
</pre></div>
</div>
</div>
</div>
<div class="section" id="community">
<h2>Community<a class="headerlink" href="#community" title="Permalink to this headline">¶</a></h2>
<div class="section" id="greedy-modularity-community-detection">
<h3>Greedy Modularity Community Detection<a class="headerlink" href="#greedy-modularity-community-detection" title="Permalink to this headline">¶</a></h3>
<p>Find communities in graph using Clauset-Newman-Moore greedy modularity maximization. This method currently supports the Graph class.</p>
<p>Greedy modularity maximization begins with each node in its own community and joins the pair of communities that most increases modularity until no such pair exists.</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">greedy_modularity_communities</span><span class="p">(</span><span class="n">G</span><span class="p">,</span> <span class="n">weight</span><span class="o">=</span><span class="s1">&#39;weight&#39;</span><span class="p">)</span>
</pre></div>
</div>
<blockquote>
<div><p>References</p>
<p>[1] M. E. J Newman ‘Networks: An Introduction’, page 224 Oxford University Press 2011.</p>
<p>[2] Clauset A, Newman M E J, Moore C. Finding community structure in very large networks[J]. Physical review E, 2004, 70(6): 066111.</p>
</div></blockquote>
</div>
</div>
<div class="section" id="structural-holes-spanners">
<h2>Structural Holes Spanners<a class="headerlink" href="#structural-holes-spanners" title="Permalink to this headline">¶</a></h2>
<p>Easy Graph has implemented several most commonly used structural holes spanners detection methods, including HIS, MaxD, HAM, Common_Greedy,  AP_Greedy. Burt‘s evaluation metric for structural holes, Effective Size, Efficiency, Constraint and Hierarchy, are also included.</p>
<div class="section" id="his-maxd">
<h3>HIS &amp; MaxD<a class="headerlink" href="#his-maxd" title="Permalink to this headline">¶</a></h3>
<p>Both <strong>HIS</strong> and <strong>MaxD</strong> are methods in [1]. The authors developed these two methods to find the structural holes spanners, base on theory of information diffusion.</p>
<p>Returns the value of <code class="docutils literal notranslate"><span class="pre">S</span></code>, <code class="docutils literal notranslate"><span class="pre">I</span></code>, <code class="docutils literal notranslate"><span class="pre">H</span></code> ,defined in <strong>HIS</strong> of [1], of each node in the graph. Note that <code class="docutils literal notranslate"><span class="pre">H</span></code> quantifies the possibility that a node is a structural hole spanner. To use <code class="docutils literal notranslate"><span class="pre">HIS</span></code> method, you should provide the community detection result as parameter.</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">get_structural_holes_HIS</span><span class="p">(</span><span class="n">G</span><span class="p">,</span>
                         <span class="n">C</span> <span class="o">=</span> <span class="p">[</span><span class="nb">frozenset</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">]),</span> <span class="nb">frozenset</span><span class="p">([</span><span class="mi">4</span><span class="p">,</span><span class="mi">5</span><span class="p">,</span><span class="mi">6</span><span class="p">])],</span> <span class="c1"># Two communities</span>
                         <span class="n">epsilon</span> <span class="o">=</span> <span class="mf">0.01</span><span class="p">,</span>
                         <span class="n">weight</span> <span class="o">=</span> <span class="s1">&#39;weight&#39;</span>
                         <span class="p">)</span>
</pre></div>
</div>
<p>Returns the top k nodes as structural hole spanners, using <strong>MaxD</strong>.</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">get_structural_holes_MaxD</span><span class="p">(</span><span class="n">G</span><span class="p">,</span>
                          <span class="n">k_size</span> <span class="o">=</span> <span class="mi">5</span><span class="p">,</span> <span class="c1"># To find top five structural holes spanners.</span>
                          <span class="n">C</span> <span class="o">=</span> <span class="p">[</span><span class="nb">frozenset</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">]),</span> <span class="nb">frozenset</span><span class="p">([</span><span class="mi">4</span><span class="p">,</span><span class="mi">5</span><span class="p">,</span><span class="mi">6</span><span class="p">])]</span> <span class="c1"># Two communities</span>
                         <span class="p">)</span>
</pre></div>
</div>
</div>
<div class="section" id="ham">
<h3>HAM<a class="headerlink" href="#ham" title="Permalink to this headline">¶</a></h3>
<p>Use <strong>HAM</strong> to jointly detect structural holes spanners as well as communities. The related research paper is [2].</p>
<p>Returns the top-k nodes as structural hole spanners, and a Ndarray of labeled communities of the nodes.</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">get_structural_holes_HAM</span><span class="p">(</span><span class="n">G</span><span class="p">,</span>
                       	 <span class="n">k</span> <span class="o">=</span> <span class="mi">2</span><span class="p">,</span> <span class="c1"># To find top two structural holes spanners.</span>
                         <span class="n">c</span> <span class="o">=</span> <span class="mi">2</span><span class="p">,</span>
                         <span class="n">ground_truth_labels</span> <span class="o">=</span> <span class="p">[[</span><span class="mi">0</span><span class="p">],</span> <span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="p">[</span><span class="mi">1</span><span class="p">]]</span> <span class="c1"># The ground truth labels for each node - community detection result, for example.</span>
                        <span class="p">)</span> 
</pre></div>
</div>
</div>
<div class="section" id="common-greedy-ap-greedy">
<h3>common_greedy &amp; AP_greedy<a class="headerlink" href="#common-greedy-ap-greedy" title="Permalink to this headline">¶</a></h3>
<p>The authors of [3] developed two methods, <strong>common_greedy</strong> and <strong>AP_greedy</strong>, to find the top k nodes as structural holes spanners. Both of them are greedy methods and <strong>AP_greedy</strong> leverages articulation points to speedup the procedure.</p>
<p>Returns the top k nodes as structural hole spanners, using <strong>common_greedy</strong>.</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">common_greedy</span><span class="p">(</span><span class="n">G</span><span class="p">,</span>
              <span class="n">k</span> <span class="o">=</span> <span class="mi">3</span><span class="p">,</span> <span class="c1"># To find top three structural holes spanners.</span>
              <span class="n">c</span> <span class="o">=</span> <span class="mf">1.0</span><span class="p">,</span> <span class="c1"># To define zeta: zeta = c * (n*n*n), and zeta is the large value assigned as the shortest distance of two unreachable vertices.</span>
              <span class="n">weight</span> <span class="o">=</span> <span class="s1">&#39;weight&#39;</span><span class="p">)</span>
</pre></div>
</div>
<p>Returns the top k nodes as structural hole spanners, using <strong>AP_greedy</strong>.</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">AP_greedy</span><span class="p">(</span><span class="n">G</span><span class="p">,</span>
          <span class="n">k</span> <span class="o">=</span> <span class="mi">3</span><span class="p">,</span> <span class="c1"># To find top three structural holes spanners.</span>
          <span class="n">c</span> <span class="o">=</span> <span class="mf">1.0</span><span class="p">,</span> <span class="c1"># To define zeta: zeta = c * (n*n*n), and zeta is the large value assigned as the shortest distance of two unreachable vertices.</span>
          <span class="n">weight</span> <span class="o">=</span> <span class="s1">&#39;weight&#39;</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="section" id="burt-s-metrics">
<h3>Burt’s Metrics<a class="headerlink" href="#burt-s-metrics" title="Permalink to this headline">¶</a></h3>
<p>When Burt put forward theory of structural hole spanners [4] in 1992, he also raised four metrics for structural hole evaluation: Effective Size, Efficiency, Constraint, Hierarchy. They are also implemented in Easy Graph.</p>
<p>Returns the Effective Size of the nodes in the graph.</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">effective_size</span><span class="p">(</span><span class="n">G</span><span class="p">,</span>
               <span class="n">nodes</span><span class="o">=</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">],</span> <span class="c1"># Compute the Effective Size of some nodes. The default is None for all nodes in G.</span>
               <span class="n">weight</span><span class="o">=</span><span class="s1">&#39;weight&#39;</span> <span class="c1"># The weight key of the graph. The default is None for unweighted graph.</span>
               <span class="p">)</span>
</pre></div>
</div>
<p>Returns the Efficiency of the nodes in the graph.</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">efficiency</span><span class="p">(</span><span class="n">G</span><span class="p">,</span>
           <span class="n">nodes</span><span class="o">=</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">],</span> <span class="c1"># Compute the Efficiency of some nodes. The default is None for all nodes in G.</span>
           <span class="n">weight</span><span class="o">=</span><span class="s1">&#39;weight&#39;</span> <span class="c1"># The weight key of the graph. The default is None for unweighted graph.</span>
           <span class="p">)</span>
</pre></div>
</div>
<p>Returns the Constraint of nodes.</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">constraint</span><span class="p">(</span><span class="n">G</span><span class="p">,</span>
           <span class="n">nodes</span><span class="o">=</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">],</span> <span class="c1"># Compute the Constraint of some nodes. The default is None for all nodes in G.</span>
           <span class="n">weight</span><span class="o">=</span><span class="s1">&#39;weight&#39;</span><span class="p">,</span> <span class="c1"># The weight key of the graph. The default is None for unweighted graph.</span>
           <span class="n">n_workers</span><span class="o">=</span><span class="mi">4</span> <span class="c1"># Parallel computing on four workers. The default is None for serial computing.</span>
           <span class="p">)</span>
</pre></div>
</div>
<blockquote>
<div><p>References</p>
<p>[1] Lou T, Tang J. Mining structural hole spanners through information diffusion in social networks[C]//Proceedings of the 22nd international conference on World Wide Web. 2013: 825-836.</p>
<p>[2] He L, Lu C T, Ma J, et al. Joint community and structural hole spanner detection via harmonic modularity[C]//Proceedings of the 22nd ACM SIGKDD International Conference on Knowledge Discovery and Data Mining. 2016: 875-884.</p>
<p>[3] Xu W, Rezvani M, Liang W, et al. Efficient Algorithms for the Identification of Top-$ k $ Structural Hole Spanners in Large Social Networks[J]. IEEE Transactions on Knowledge and Data Engineering, 2017, 29(5): 1017-1030.</p>
<p>[4] Burt R S. Structural holes: The social structure of competition[M]. Harvard university press, 2009.</p>
</div></blockquote>
</div>
</div>
<div class="section" id="graph-embedding">
<h2>Graph Embedding<a class="headerlink" href="#graph-embedding" title="Permalink to this headline">¶</a></h2>
<p>Easy Graph has implemented several methods of graph embedding.</p>
<div class="section" id="deepwalk">
<h3>DeepWalk<a class="headerlink" href="#deepwalk" title="Permalink to this headline">¶</a></h3>
<p>Returns</p>
<ol class="simple">
<li><p>The embedding vector of each node via DeepWalk [1]</p></li>
<li><p>The most similar nodes of each node and its similarity</p></li>
</ol>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">deepwalk</span><span class="p">(</span><span class="n">G</span><span class="p">,</span>
         <span class="n">dimensions</span><span class="o">=</span><span class="mi">128</span><span class="p">,</span> <span class="c1"># The graph embedding dimensions.</span>
         <span class="n">walk_length</span><span class="o">=</span><span class="mi">80</span><span class="p">,</span> <span class="c1"># Walk length of each random walks.</span>
         <span class="n">num_walks</span><span class="o">=</span><span class="mi">10</span><span class="p">,</span> <span class="c1"># Number of random walks.</span>
         <span class="n">skip_gram_params</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">(</span> <span class="c1"># The skip_gram parameters in Python package gensim.</span>
         	<span class="n">window</span><span class="o">=</span><span class="mi">10</span><span class="p">,</span>
            <span class="n">min_count</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span>
            <span class="n">batch_words</span><span class="o">=</span><span class="mi">4</span><span class="p">,</span>
            <span class="nb">iter</span><span class="o">=</span><span class="mi">15</span>
         <span class="p">))</span>
</pre></div>
</div>
</div>
<div class="section" id="node2vec">
<h3>Node2Vec<a class="headerlink" href="#node2vec" title="Permalink to this headline">¶</a></h3>
<p>Returns</p>
<ol class="simple">
<li><p>The embedding vector of each node via node2vec [2]</p></li>
<li><p>The most similar nodes of each node and its similarity</p></li>
</ol>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">node2vec</span><span class="p">(</span><span class="n">G</span><span class="p">,</span>
         <span class="n">dimensions</span><span class="o">=</span><span class="mi">128</span><span class="p">,</span> <span class="c1"># The graph embedding dimensions.</span>
         <span class="n">walk_length</span><span class="o">=</span><span class="mi">80</span><span class="p">,</span> <span class="c1"># Walk length of each random walks.</span>
         <span class="n">num_walks</span><span class="o">=</span><span class="mi">10</span><span class="p">,</span> <span class="c1"># Number of random walks.</span>
         <span class="n">p</span><span class="o">=</span><span class="mf">1.0</span><span class="p">,</span> <span class="c1"># The `p` possibility in random walk in [2]</span>
         <span class="n">q</span><span class="o">=</span><span class="mf">1.0</span><span class="p">,</span> <span class="c1"># The `q` possibility in random walk in [2]</span>
         <span class="n">weight_key</span><span class="o">=</span><span class="s1">&#39;weight&#39;</span><span class="p">,</span>
         <span class="n">skip_gram_params</span><span class="o">=</span><span class="nb">dict</span><span class="p">(</span> <span class="c1"># The skip_gram parameters in Python package gensim.</span>
         	<span class="n">window</span><span class="o">=</span><span class="mi">10</span><span class="p">,</span>
            <span class="n">min_count</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span>
            <span class="n">batch_words</span><span class="o">=</span><span class="mi">4</span>
         <span class="p">))</span>
</pre></div>
</div>
</div>
<div class="section" id="line">
<h3>LINE<a class="headerlink" href="#line" title="Permalink to this headline">¶</a></h3>
<p><strong>LINE</strong> is a graph embedding method in [3].</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">model</span> <span class="o">=</span> <span class="n">LINE</span><span class="p">(</span><span class="n">G</span><span class="p">,</span> 
             <span class="n">embedding_size</span><span class="o">=</span><span class="mi">16</span><span class="p">,</span> 
             <span class="n">order</span><span class="o">=</span><span class="s1">&#39;all&#39;</span><span class="p">)</span> <span class="c1"># The order of model LINE. &#39;first&#39;，&#39;second&#39; or &#39;all&#39;.</span>

<span class="n">model</span><span class="o">.</span><span class="n">train</span><span class="p">(</span><span class="n">batch_size</span><span class="o">=</span><span class="mi">1024</span><span class="p">,</span> <span class="n">epochs</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">verbose</span><span class="o">=</span><span class="mi">2</span><span class="p">)</span>
<span class="n">embeddings</span> <span class="o">=</span> <span class="n">model</span><span class="o">.</span><span class="n">get_embeddings</span><span class="p">()</span> <span class="c1"># Returns the graph embedding results.</span>
</pre></div>
</div>
</div>
<div class="section" id="sdne">
<h3>SDNE<a class="headerlink" href="#sdne" title="Permalink to this headline">¶</a></h3>
<p><strong>SDNE</strong> is a graph embedding method in [4].</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">model</span> <span class="o">=</span> <span class="n">SDNE</span><span class="p">(</span><span class="n">G</span><span class="p">,</span> 
             <span class="n">hidden_size</span><span class="o">=</span><span class="p">[</span><span class="mi">256</span><span class="p">,</span> <span class="mi">128</span><span class="p">])</span> <span class="c1"># The hidden size in SDNE.</span>

<span class="n">model</span><span class="o">.</span><span class="n">train</span><span class="p">(</span><span class="n">batch_size</span><span class="o">=</span><span class="mi">3000</span><span class="p">,</span> <span class="n">epochs</span><span class="o">=</span><span class="mi">40</span><span class="p">,</span> <span class="n">verbose</span><span class="o">=</span><span class="mi">2</span><span class="p">)</span>
<span class="n">embeddings</span> <span class="o">=</span> <span class="n">model</span><span class="o">.</span><span class="n">get_embeddings</span><span class="p">()</span> <span class="c1"># Returns the graph embedding results.</span>
</pre></div>
</div>
<blockquote>
<div><p>References</p>
<p>[1] Perozzi B, Al-Rfou R, Skiena S. Deepwalk: Online learning of social representations[C]//Proceedings of the 20th ACM SIGKDD international conference on Knowledge Discovery and Data mining. 2014: 701-710.</p>
<p>[2] Grover A, Leskovec J. node2vec: Scalable feature learning for networks[C]//Proceedings of the 22nd ACM SIGKDD international conference on Knowledge Discovery and Data mining. 2016: 855-864.</p>
<p>[3] Tang J, Qu M, Wang M, et al. Line: Large-scale information network embedding[C]//Proceedings of the 24th international conference on World Wide Web. 2015: 1067-1077</p>
<p>[4] Wang D, Cui P, Zhu W. Structural deep network embedding[C]//Proceedings of the 22nd ACM SIGKDD international conference on Knowledge Discovery and Data mining. 2016: 1225-1234.</p>
</div></blockquote>
</div>
</div>
</div>


          </div>
          
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
<h1 class="logo"><a href="index.html">Easy Graph</a></h1>








<h3>Navigation</h3>
<p class="caption"><span class="caption-text">Contents:</span></p>
<ul class="current">
<li class="toctree-l1 current"><a class="current reference internal" href="#">Functions</a><ul>
<li class="toctree-l2"><a class="reference internal" href="#components">Components</a></li>
<li class="toctree-l2"><a class="reference internal" href="#community">Community</a></li>
<li class="toctree-l2"><a class="reference internal" href="#structural-holes-spanners">Structural Holes Spanners</a></li>
<li class="toctree-l2"><a class="reference internal" href="#graph-embedding">Graph Embedding</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="Graph Classes.html">Graph Classes</a></li>
</ul>

<div class="relations">
<h3>Related Topics</h3>
<ul>
  <li><a href="index.html">Documentation overview</a><ul>
      <li>Previous: <a href="index.html" title="previous chapter">Welcome to test’s documentation!</a></li>
      <li>Next: <a href="Graph Classes.html" title="next chapter">Graph Classes</a></li>
  </ul></li>
</ul>
</div>
<div id="searchbox" style="display: none" role="search">
  <h3 id="searchlabel">Quick search</h3>
    <div class="searchformwrapper">
    <form class="search" action="search.html" method="get">
      <input type="text" name="q" aria-labelledby="searchlabel" />
      <input type="submit" value="Go" />
    </form>
    </div>
</div>
<script>$('#searchbox').show(0);</script>








        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="footer">
      &copy;2020, lizheng.
      
      |
      Powered by <a href="http://sphinx-doc.org/">Sphinx 3.1.2</a>
      &amp; <a href="https://github.com/bitprophet/alabaster">Alabaster 0.7.12</a>
      
      |
      <a href="_sources/Functions.md.txt"
          rel="nofollow">Page source</a>
    </div>

    

    
  </body>
</html>